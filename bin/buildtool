#!/bin/bash
########################################################################
# buildtool
#
#   General purpose CMake / build script for packages using cetmodules
#   or cetbuildtools.
#
# Chris Green <greenc@fnal.gov>
#
# 2011/11/10
########################################################################

real_dir() {
  [ -d "$1" ] && \
    (cd "$1" >/dev/null 2>&1 && pwd -P) 2>/dev/null
}

cmake_version() {
  [ -n "$1" ] || { cat >/dev/null 2>/dev/null; return; }
  printf "$1=(%s)" "$(sed -nEe \
    '1 s&^(cmake version )?([[:digit:]]+)(\.([[:digit:]]+))?(\.([[:digit:]]+))?(-(.+))?$&\"\2\" \"\4\" \"\6\" \"\8\"&p')"
}

# Program name.
prog=${0##*/}

# Private utilities.
libexec="$(cd "${BASH_SOURCE%/*}/../libexec" && pwd -P)"

. "$libexec/message_functions.sh" || \
  { echo "ERROR: could not find essential functions in $libexec/message_functions.sh" \
         1>&2; exit 1; }

# CMake version.
eval $(cmake --version | cmake_version running_cmake_version)

# Usage.
usage() {
  local exitval long
  [ "$1" = long ] && { long=1; shift; }
  (( exitval = ${1:-1} ))
  cat <<EOF
USAGE: $prog [<mode-options>] [<misc-options>] [--] \\
                 [<cmake-build-options>] [-- <generator-options>]
       $prog --help|-h
       $prog --usage

Mode options: [-C|--cmake-only|-A|--all|--info] ||
              { [-b|--build] [-i|--install] [-p|--package] [-t|--test] }

Combo options: [-R|--release] || [-T|--test-all]

Misc options: [-D<CMake-definition>]+
              [-E|--export-compile-commands]
              [-G<CMake-generator-string>]
              [-I|--install-prefix <install-location>]
              [--L <label-regex>]
              [--LE <label-regex>]
              [-c|--clean]
              [--clean-logs]
              [-X(c|b|t|i),<arg>[,<arg>]+]
              [--cmake-debug]
              [--cmake-trace]
              [--cmake-trace-expand]
              [--deleted-header[s] <header>[,<header>]+]
              [-f|--force-top]
              [-g|--graphviz=<dot-file> [--gfilt <gfilt-opt>[,<gfilt-opt>]+]]
              [--generator <make|ninja>[:<secondary-generator>]]
              [-j #]
              [-l|--log[=<log-file>]|--log-file[=<log-file>]]
              [--no-pc|--no-preset-configure]
              [--pc|--preset-configure <preset-name>]
              [-q|--quiet]
              [-s|--subdir]
              [--tee]
              [--test-labels|--labels|--test-groups|--groups <group>[<;|,><group>]+]
              [-v|--verbose]

Options suffixed with '+' are repeatable and cumulative. If a
non-repeatable option is specified multiple times, last invocation wins.

The -G and --generator options are mutually-exclusive, and may be specified at most once.

Required environment: CETPKG_BUILD CETPKG_SOURCE
Optional environment: CETPKG_INSTALL CETPKG_J

EOF
  (( long )) && cat <<EOF

DETAILS.

Required environment variables:

CETPKG_BUILD:   The build area for the current package.

Optional environment variables:

CETPKG_INSTALL: The default location of the private (or public) UPS
                products area into which to install the package if
                install is requested. This is overridden by -I option,
                but will override existing CMAKE_INSTALL_PREFIX from
                CMake.
CETPKG_J:       Default parallelism for all appropriate steps, assuming
                -j is not specified explicitly.

Other configuration items;

The following items are obtained from the package's
cetpkg_info.sh file, which is generated by sourcing
setup_for_development:

CETPKG_SOURCE:  The source area for the current package (containing the
                top-level CMakeLists.txt).


MODE OPTIONS.

If any of -A (--all), C (--cmake-only) or --info are set, they override
all other mode options. The cmake-only mode overrides the all
option. If any of the other options are selected, they will be executed
in their natural order *after* the CMake stage (which is always executed
in the CETPKG_BUILD directory).

-A
--all

  Execute all stages.

-C
--cmake-only

  Execute *only* the CMake stage.

-b
--build

  Execute the build stage from the current directory. This is default if
  no other mode option is specified.

-i
--install

  Execute the install stage from CETPKG_BUILD. CMake's generated build
  procedure will ensure that all build targets are up to date, so an
  accompanying explicit --build option is unnecessary.

--info

  If already configured (CMake has been run at least once since the last
  clean), give some basic information about the package, then exit.

-p
--package

  Execute the package stage from CETPKG_BUILD to create a binary
  installation archive. As for --install, CMake's generated build
  procedure will ensure that all build targets are up to date so an
  accompanying explicit --build option is unnecessary. Note that
  --package does *not* imply --install: the two operations are
  independent.

--short-circuit
--sc

  Execute only the specified stages and not those that might be implied
  (CMake stage, build stage when test stage is specified, etc).

-t
--test

  Execute configured tests with ctest from the current
  directory. Implies --build.


COMBO MODE OPTIONS.

-R
--release

  Equivalent to -t --test-labels=RELEASE.

-T
--test-all

  Equivalent to -t --test-labels=ALL.


MISC. OPTIONS.

-D<CMake-definition>

  Pass definitions to the invocation of the CMake stage. A warning shall
  be issued if this option is specified but the CMake stage is not to be
  executed.

-E
--export-compile-commands

  Equivalent to -DCMAKE_EXPORT_COMPILE_COMMANDS:BOOL=ON. Useful for
  (e.g.) clang-tidy.

-G<CMake-generator-string>

  Pass the specified CMake generator string through to CMake. Note that,
  at this time, only the "Unix Makefiles" and Ninja generators are
  supported by buildtool. Any secondary generator specification is
  passed through unexamined.

-I <ups-install-dir>
--install-prefix <ups-install-dir>

  Specify the location of the private (or public) UPS products area into
  which to install the package if install is requested. Overrides the
  CETPKG_INSTALL environment variable and anything already known to
  CMake.

--L <label-regex>
--LE <label-regex>

  Per CTest, include (--L) or exclude (--LE) labels by CMake regex. Both
  options are mutually exclusive with --test-labels, -T and -R, but not
  with each other. Specifying one of these options implies -t.

-X[cbtip],<arg>[,<arg>]+[,--,<non-option-arg>[,<non-option-arg>]+]

  EXtra arguments to be passed to the Configure, Build, Test, Install,
  or Package stages. <arg>s will be added at the end of option
  arguments, while <non-option-arg>s will be added at the end of
  non-option arguments.

-c
--clean

  Remove CMake-generated files and caches and other build products.

--clean-logs

  Remove .log files in the \$CETPKG_BUILD top directory.

--cmake-debug

  Add --debug-output to the CMake command line options.

--cmake-trace

  Add --trace to the CMake command line options.

--cmake-trace-expand

  Add --trace-expand to the CMake command line options.

--deleted-header[s] <header>[,<header>]+

  Indicate that named headers have been removed from the source, to
  allow removal and regeneration of dependency files containing
  references to same.

--force-top

  Force build and test stages (if applicable) to be executed from the
  top level \$CETPKG_BUILD area. Otherwise these stages will execute
  within the context of the user's current directory at invocation if it
  is below \$CETPKG_BUILD. --force-top is incompatible with --subdir. In
  any event, any relative or unqualified log file will be output
  relative to the user's current directory at the time buildtool was
  invoked.

-g <dot-file>
--graphviz <dot-file>

  Ask CMake to produce a code dependency graph in graphviz (.dot) format.

  Note that CMake can only tell you about the dependencies about which
  it knows. Libraries must have their dependencies resolved at library
  production time (NO_UNDEFINED) in order for the information to be
  complete.

--gfilt[=<opt>[,<opt>]+]

  Filter the graphviz output from CMake through cmake-graphviz-filt,
  with the following options:

    exes|no-exes

      With or without executables shown (default without).

    dicts|no-dicts

      With or without dictionary and map libraries (default without).

    extlibs|no-extlibs

      With or without extlibs shown (default without).

    short-libnames|no-short-libnames

      Any fully-specified library pathnames are shortened to their
      basenames (default long).

    test-tree|no-test-tree

      With or without libraries and execs from the test directory
      hierarchy (default without).

    tred|no-tred

      With or without transitive dependency reduction (default with).

  Multiple options should be comma-separated. Note that all of these
  options may be specified in ~/.cgfrc for the same effect (command-line
  overrides).

--generator <generator>[:<secondary-generator>]

  User-friendly way to specify the generator. Currently supported values
  are "make" and "ninja" (default make). If <secondary-generator>
  (e.g. CodeBlocks) is specified it will be passed through as-is.

-h|--help

  This help (long-form).

-j #

  Specify the level of parallelism for stages for which it is
  appropriate (overrides CETPKG_J if specified).

-l
--log[=<log-dir-or-filepath>]
--log-file[=<log-dir-or-filepath>]

  All build output is redirected to the specified log-file, or one with
  a default name if no other is specified. Unless --quiet is also
  specified, stage information will still be printed to the screen,
  though see --tee below. Note that the short variant does not accept an
  argument: a log-file name will be generated. The long forms should use
  "=" to separate the option from its argument.

-q
--quiet

  Suppress all non-error output to the screen (but see --tee below). A
  log file will still be written as normal if so specified.

-s <subdir>
--subdir <subdir>

  Execute build and install stages from the context of <subdir>, which
  will be interpreted relative to \$CETPKG_BUILD. Incompatible with
  --force-top. <subdir> will be used in preference to the current user
  directory, even if the latter is a subdirectory of \$CETPKG_BUILD.

--tee

  Write to a log file (either as specified by --log or the default), but
  copy output to the screen also: --quiet is overridden by this option.

--test-labels <group>[<;|,><group>]+
--labels <group>[<;|,><group>]+
--test-groups <group>[<;|,><group>]+
--groups <group>[<;|,><group>]+

  Specify optional CMake test labels to execute. Since cetbuildtools
  v6_00_00, this is integrated with the CMake labels facility, and the
  test selection is done at CTest invocation time rather than CMake time
  as previously. If this option is activated but tests are not to be
  run, a warning shall be issued. If no labels are selected, then
  DEFAULT is selected. A value of ALL is substituted with all known test
  labels. A leading \`-' for a label will lead to its explicit
  exclusion. See also -T, -R options. Mutually-exclusive with --L and
  --LE options.

--usage

  Short help.

-v
--verbose

  Extra information about the commands being executed at each step


EXAMPLES.

Build, test, install and create a package tarball from scratch with
output to a default-named log file, using parallelism:

  $prog -A -c -l -I <install-dir> -j16

As above, but copying output to screen:

  $prog -A -c -l --tee -I <install-dir> -j16

The need for the -I option may be obviated by defining CETPKG_INSTALL;
the need for the explicit parallelism may be similarly voided by
defining (eg) CETPKG_J=16.

To build only a particular target within a subdirectory:

  buildtool --subdir art/Framework/IO/Root -- RootOutput_source.o

To build and test only:

  buildtool -t -j16

To install and package only:

  buildtool -i -p -j16
EOF

  exit $exitval
}

##################
# Obtain information from CMake.
cmake_var() {
  local val
  { val=$(cmake -N -LA -B "$CETPKG_BUILD" | \
    grep -Ee '^'"$1"':'); } 2>/dev/null
  (( $? == 0 )) && [ -n "$val" ] && echo "${val#*=}"
}

# Obtain CMake system information (includes internal variables,
# command-line definitions that are later overridden, etc.).
cmake_sys_var() {
  local val
  { val=$(cd "$CETPKG_BUILD" && \
    cmake -N --system-information | \
    grep -Fe '^'"$1"':'); } 2>/dev/null
  (( $? == 0 )) && [ -n "$val" ] && echo "${val#*=}"
}

cmake_to_bash_list() { var="$1"; shift; local IFS=";"; eval $var=\(\${*:+"$@"}\); }

known_test_labels() {
  local -a known_labels
  cmake_to_bash_list known_labels "$(cmake_var CET_DEFINED_TEST_GROUPS)"
  (( ${#known_labels[@]} )) && \
    echo "test labels known to CMake: ${known_labels[*]}"
}

basic_info() {
    "$CETPKG_BUILD/cetpkg_info.sh" || \
      fatal_error "No file \$CETPKG_BUILD/cetpkg_info.sh - source setup_for_development?"
    known_test_labels || true
}

# Banner line
banner() {
  (( quiet )) && return
  if [ -n "$2" ]; then
    local redir="1>&$1"
    shift
  fi
  eval cat $redir <<EOF

------------------------------------
$1
------------------------------------

EOF
}

log_no_tee() { [ -n "$log" ] && (( ! tee )); }

cmd() {
  local OPT desc OPTARG wd OPTIND
  while getopts :d:w: OPT; do
    case $OPT in
      d) desc="$OPTARG";;
      w) wd="$OPTARG";;
      *) internal_error "check buildtool's use of cmd function"
    esac
  done
  shift $(( OPTIND - 1 ))
  if (( _cet_do_verbose )); then
    local cmd_short="$*"
    if [ "$1" = "$lock_cmd" ]; then
      cmd_short="${cmd_short#*-- }"
    fi
    writeStuff "COMMAND: ${cmd_short}\nWD: ${wd:-$(pwd -P)}${desc+\nDESCRIPTION: $desc}"
  fi
  SECONDS=0
  ( if [ -n "$wd" ]; then cd "$wd" || exit; fi; "$@" ); local status=$?; echo
  (( _cet_do_verbose )) && \
    writeStuff "$(printf "TIME ELAPSED: %d:%02d\n" $(($SECONDS / 60)) $(($SECONDS % 60)))"
  return $status
}

# Check status and exit if necessary
check_status() {
  local status=${1:-$?} # Caller may override.
  if (( status == 0 )); then
    banner "$(info "stage $stage SUCCESS${build_info:+ for $build_info}")"
    return $status
  else
    if (( _cet_redirected )); then
      banner 2 "$(eval "( fatal_error \"stage $stage FAILED${build_info:+ for $build_info}\" 2>&1 4>/dev/null)")"
    else printf -- "\n"
    fi
    eval "fatal_error $status \"stage $stage FAILED${build_info:+ for $build_info} with code $status\" \
${_cet_redirected:+\"\\n             See $log for details\" 2>/dev/null}"
    exit $status
  fi
}

announce_stage() {
  eval 'printf "\n"' ${_cet_redirected:+1>&3}
  banner "$(info "stage $stage${build_info:+ for $build_info}$@")"
}

calculate_ops_dir() {
  if (( force_top )); then
    # Override.
    ops_dir=
    ops_dir_reason=" per --force-top"
  elif [ -n "$subdir" ]; then
    # Specified subdir.
    ops_dir="$subdir"
    ops_dir_reason=" per --subdir"
  else
    if [ -z "$user_subdir" ] || [ "$user_subdir" = "$user_cwd" ]; then
      ops_dir=""
    else # User CWD is under CETPKG_BUILD.
      ops_dir="$user_subdir"
    fi
    ops_dir_reason=" per user CWD"
  fi
  if [ -n "$ops_dir" ]; then
    # Get absolute.
    real_ops_dir=$(real_dir "$CETPKG_BUILD/$ops_dir")
    if (( $? )); then
      echo "ERROR: unable to verify validity of specified subdirectory: $ops_dir" 1>&2
      exit 1
    fi
  fi
}

cleanup() {
  [ -d "$TMP" ] && rm -rf "$TMP"
}

declare -a deleted_headers

# Deleted headers.
add_deleted_headers() {
  local IFS=","
  deleted_headers+=($1)
}

# Funky argument parsing.
process_gfargs() {
  local oifs="$IFS"
  IFS=,
  for opt in $1; do
    case $opt in
      dicts|no-dicts|exes|no-exes|extlibs|no-extlibs|short-libnames|no-short-libnames|test-tree|no-test-tree)
        gfargs+=(--$opt);
      ;;
      tred)
        (( tred = 1 ))
      ;;
      no-tred)
        unset tred
        :
      ;;
      *)
        echo "Unrecognized gfilt option \"$opt\"" 1>&2
        usage 1
    esac
  done
  IFS="$oifs"
}

label_regex() {
  if (( $# )); then
    local IFS="|"
    printf '^(%s)$' "$*"
  fi
}

test_spec_args() {
  tsargs=()
  if (( ${#test_labels[@]} )); then
    local l=() le=()
    for label in "${test_labels[@]}"; do
      if [ "$(echo "${label#-}" | tr '[a-z]' '[A-Z]')" = "ALL" ]; then
        # Short-circuit
        tsargs=()
        return
      fi
      if [[ "$label" == -* ]]; then
        le+=("${label#-}")
      else
        l+=("$label")
      fi
    done
    local l_regex=$(label_regex ${l[@]:+"${l[@]}"})
    local le_regex=$(label_regex ${le[@]:+"${le[@]}"})
  fi
  tsargs=(${l_regex:+-L "$l_regex"} ${le_regex:+-LE "$le_regex"})
  (( ${#tsargs[@]} == 0 )) && tsargs=(-L '^DEFAULT$')
}

# Main work
do_work() {
  local -a cmake_build_user_options generator_user_args
  local build_info=
  if [ -n "$MRB_BUILDDIR" -a -n "$MRB_PROJECT" -a \
    "$MRB_SOURCE" = "$CETPKG_SOURCE" -a \
    "$MRB_BUILDDIR" = "$CETPKG_BUILD" ]; then
    build_info="MRB project $MRB_PROJECT $MRB_PROJECT_VERSION"
    (( using_mrb = 1 ))
  elif [ -n "$CETPKG_NAME" -a -n "$CETPKG_VERSION" ]; then
    build_info="$CETPKG_NAME $CETPKG_VERSION"
    unset using_mrb
  else
    fatal_error "unable to ascertain what to build - incomplete environment?"
  fi
  while [ -n "$1" ]; do
    case $1 in
      --) shift; break;;
      *) cmake_build_user_options+=("$1"); shift
    esac
  done
  generator_user_args=("$@")
  maybe_redirect
  stage=cmake
  if (( short_circuit )) && ! (( cmake_only )); then
    announce_stage " SKIPPED per --short-circuit"
    (( ${#cmake_options[@]} )) || (( ${#cmake_defs[@]} )) ||
    warning "CMake options and definitions ignored since CMake not invoked:" \
      ${cmake_options[*]} ${cmake_defs[*]}
  else
    announce_stage
    # Remove references to deleted headers.
    (( ${#deleted_headers[@]} )) && [ -d CMakeFiles ] && \
      cmd -d "remove references to deleted headers" \
          -w "$CETPKG_BUILD" \
          ${lock_cmd[*]:+"${lock_cmd[@]}" -- } \
          "$libexec/remove_deleted_header_refs" "${deleted_headers[@]}" || true
    # Where definitions include comma-delimted lists, turn them into
    # CMake's list delimiter instead.
    cmake_defs=(${cmake_defs:+"${cmake_defs[@]//,/;}"})
    # CMake 3.13 required for -S / -B.
    require_cmake 3.13
    [ -z "${c_postargs[*]}" ] || \
      error "specifying non-option arguments for configure step (${c_postargs[*]}) is not meaningful"
    # Default preset if we haven't specified one.
    [ -n "${preset_configure}" ] || [ -z "${preset_configure-x}" ] || \
      ! has_for_UPS_preset || preset_configure="for_UPS"
    local cmake_args=()
    if [ -n "$preset_configure" ]; then
      cmake_args+=(--preset=$preset_configure)
    else
      cmake_args+=(${CETPKG_CMAKE_ARGS[*]:+"${CETPKG_CMAKE_ARGS[@]}"})
    fi
    cmake_args+=(
      ${install_prefix:+-DCMAKE_INSTALL_PREFIX="$install_prefix"}
      ${garg[*]:+"${garg[@]}"}
      ${cmake_options[*]:+"${cmake_options[@]}"}
      ${cmake_bootstrap_defs[*]:+"${cmake_bootstrap_defs[@]}"}
      ${cmake_defs[*]:+"${cmake_defs[@]}"}
      ${generator_arg:+"$generator_arg"}
      ${c_opt_args[*]:+"${c_opt_args[@]}"}
      -S "$CETPKG_SOURCE" -B "$CETPKG_BUILD"
    )
    cmd -d "execute CMake" \
      ${lock_cmd[*]:+"${lock_cmd[@]}" -- } \
      cmake ${cmake_args[*]:+"${cmake_args[@]}"} || \
      check_status # Fail here if there's a problem, quiet otherwise.
    if [ -f "$gtmpfile" ]; then
      if (( gfilt )); then
        cat "$gtmpfile" | \
          eval "$libexec/cmake-graphviz-filt \"\${gfargs[@]}\" \
${tred:+| tred} > \"$gfile\""
      else
        mv "$gtmpfile" "$gfile"
      fi
    fi
    check_status
    info "$build_info configured"
    if (( clean )) && [ -d "$install_prefix" ]; then
      # Removing installed flavorqual-specific files.
      if [ -n "$CETPKG_FQ_DIR" ] && [ -d "$install_prefix/$CETPKG_FQ_DIR" ]; then
        local fq_dir="$install_prefix/$CETPKG_FQ_DIR"
        info "cleaning flavor-specific install dir \"$fq_dir\""
        rm -rf "$fq_dir"
      fi
    fi
    (( cmake_only )) && exit 0
  fi

  if (( do_build )); then
    stage=build
    if (( do_build > 1 && short_circuit )); then
      announce_stage " SKIPPED per --short-circuit"
    else
      announce_stage
      local extra_cmake_build_options=() extra_generator_args=()
      if [ -n "$ops_dir" ]; then
        if (( using_ninja )); then
          extra_cmake_build_options+=(-t "${ops_dir:+$ops_dir/all}")
        else
          extra_generator_args+=(-C "$ops_dir")
        fi
      fi
      cmd -d "execute build" \
        ${lock_cmd[*]:+"${lock_cmd[@]}" -- } \
        cmake --build "$CETPKG_BUILD" \
        ${extra_cmake_build_options[@]:+"${extra_cmake_build_options[@]}"} \
        ${cmake_build_user_options[@]:+"${cmake_build_user_options[@]}"} \
        ${b_opt_args[*]:+"${b_opt_args[@]}"} \
        "--" \
        ${extra_generator_args[@]:+"${extra_generator_args[@]}"} \
        ${generator_user_args[@]:+"${generator_user_args[@]}"} \
        ${b_postargs[*]:+"${b_postargs[@]}"}
      check_status
    fi
  fi

  if (( do_test )); then
    stage=test
    local status= build_testing= skip_msg=
    build_testing=$(cmake_var BUILD_TESTING)
    status=$?
    if ! { (( status == 0 )) || [ -f "$CETPKG_BUILD/CTestTestfile.cmake" ]; }; then
      skip_msg=" SKIPPED: no tests configured"
    elif  [[ "$build_testing" =~ ^(0|OFF|NO?|FALSE|IGNORE|(.+-)?NOTFOUND)?$ ]]; then
      skip_msg=" SKIPPED: BUILD_TESTING set FALSE in CMake Cache"
    elif (( do_test > 1 )) && (( short_circuit )); then
      skip_msg=" SKIPPED per --short-circuit"
    fi
    if [ -n "${skip_msg}" ]; then
      announce_stage "$skip_msg"
      unset do_test
    else
      announce_stage
      test_spec_args
      if (( ${#tsargs[@]} )); then
        local known_test_labels="$(known_test_labels)"
        info "${known_test_labels:+$known_test_labels\n}test selection arguments: ${tsargs[*]}"
      fi
      # Trap and tee *only* stderr from ctest. Yes, this is fiddly.
      exec 5>&1
      [ -z "${t_postargs[*]}" ] || \
        error "specifying non-option arguments for test step (${t_postargs[*]}) is not meaningful"
      { { set +x; } 2>/dev/null # Don't need to see this.
        cmd -d "execute tests" -w "$CETPKG_BUILD"${ops_dir:+"/$ops_dir"} \
          ${lock_cmd[*]:+"${lock_cmd[@]}" -- } \
          ctest ${tsargs[*]:+"${tsargs[@]}"} \
          ${t_opt_args[*]:+"${t_opt_args[@]}"} \
          2>&1 >&5 5>&-
        echo $? > "$TMP/status.dat"
      } | tee "$TMP/ctest.err" 5>&-;
      exec 5>&-
      (( status = $(cat "$TMP/status.dat") ))
      if (( status == 0 )) && [ -s "$TMP/ctest.err" ]; then
        local err=$(cat "$TMP/ctest.err")
        if (( $(echo "$err" | wc -l) == 1 )) && \
          [ "$err" = "No tests were found!!!" ]; then
          # If this is the only output, then chances are there were no tests.
          check_status $status
        else
          error "\nERROR: detected stderr output from ctest"
          check_status 1
        fi
      else
        check_status $status
      fi
    fi
  elif [ -n "$test_labels$l_regex$le_regex" ]; then
    local test_specs="${test_labels:+--test-labels ${test_labels// /,}}"
    if [ -z "$test_specs" ]; then
      test_specs="${l_regex:+--L \"$l_regex\"}"
      [ -n "$le_regex" ] && test_specs="${test_specs:+$test_specs }--LE \"$le_regex\""
    fi
    warning "test label specifications $test_specs ignored since tests are skipped"
  fi
  if (( do_install )); then
    stage_ip install
  fi
  if (( do_package )); then
    stage_ip package
  fi
}

stage_ip() {
  stage="$1"
  local stage_regex
  local s="${1:0:1}"
  if (( using_ninja )); then
    stage_regex="^$stage:"
  else
    stage_regex='^\.\.\.[[:space:]]+'"$stage"'$'
  fi
  local cmd=()
  local cmake_build=(cmake --build "$CETPKG_BUILD")
  local cmake_build_args=(
    ${extra_cmake_build_options[@]:+"${extra_cmake_build_options[@]}"}
    ${cmake_build_user_options[@]:+"${cmake_build_user_options[@]}"}
  )
  local cmake_build_postargs=(
    ${extra_generator_args[@]:+"${extra_generator_args[@]}"}
    ${generator_user_args[@]:+"${generator_user_args[@]}"}
  )
  eval local opt_args=\(\$\{${s}_opt_args\[*\]:+\"\$\{${s}_opt_args\[@\]\}\"\}\)
  eval local postargs=\(\$\{${s}_postargs\[*\]:+\"\$\{${s}_postargs\[@\]\}\"\}\)
  local ip_lock=()
  if [ "$s" = p ] && (( using_mrb )); then
    # Use mrb mp because CMake's packaging facility can create only one
    # package and we need one per product.
    cmd=(mrb mp ${opt_args[@]:+"${opt_args[@]}"} -- )
    cmake_build_args+=(${postargs[@]:+"${postargs[@]}"})
    # N.B. *WE DO NOT LOCK*, relying on mrb mp for this.
  else # Use cmake build.
    cmd=("${cmake_build[@]}"
         -t "${stage}")
    cmake_build_args+=(${opt_args[@]:+"${opt_args[@]}"})
    cmake_build_postargs+=(${postargs[@]:+"${postargs[@]}"})
    ip_lock=(${lock_cmd[*]:+"${lock_cmd[@]}" -r ${stage/#install/${CETPKG_INSTALL:+"$CETPKG_INSTALL/.locks":}install} -- })
  fi
  # Invoke cmake build (being *very* careful with arguments).
  if (( using_mrb )) || \
       "${cmake_build[@]}" \
         ${cmake_build_args[@]:+"${cmake_build_args[@]}"} -t help \
         ${cmake_build_postargs[@]:+-- "${cmake_build_postargs[@]}"} | \
         grep -Ee "${stage_regex}" >/dev/null 2>&1; then
    announce_stage
    cmd -d "$stage" \
      ${ip_lock[*]:+"${ip_lock[@]}"} \
      "${cmd[@]}" ${cmake_build_args[@]:+"${cmake_build_args[@]}"} \
      ${cmake_build_postargs[@]:+-- "${cmake_build_postargs[@]}"}
    check_status
  else
    announce_stage " SKIPPED - target $stage not configured"
  fi
}

ensure_unique_gen() {
  if (( ${#seen_gen_arg[@]} > 0 )); then
    error "Only one generator specifcation argument is permitted: user specified:\n" \
          "${seen_gen_arg[@]} and\n" \
          "$@"
  fi
  seen_gen_arg=("$@")
}

require_tests() {
  (( do_build )) || (( do_build = 2 ))
  (( do_test = 1 ))
}

require_cmake() {
  eval local $(echo "$1" | cmake_version req_cmake_version)
  (( ${running_cmake_version[0]:-0} < ${req_cmake_version[0]:-0} )) || \
    (( ${running_cmake_version[1]:-0} < ${req_cmake_version[1]:-0} )) || \
    (( ${running_cmake_version[2]:-0} < ${req_cmake_version[2]:-0} )) || \
    (( ${running_cmake_version[3]:-0} < ${req_cmake_version[3]:-0} )) || return 0
  local OIFS="$IFS" IFS='.'
  local msg="${2:-buildtool} requires CMake >= $1 (found ${running_cmake_version[*]}) - setup issues?"
  IFS="$OIFS"
  fatal_error "$msg"
  return 1
}

has_for_UPS_preset() {
  local label
  while read label; do
    [ "$label" = "for_UPS" ] && return
  done < <( cmake -S "$CETPKG_SOURCE" --list-presets=configure 2>/dev/null | sed -Ene 's&^[[:space:]]*"([^"]+)".*&\1&p'  )
  return 1
}

########################################################################
# Main
########################################################################

# Initialization.
log_default="build_`date \"+%Y-%m-%d\"`.log"
(( tred = 1 ))
declare -a cmake_options

# Temporary directory.
TMP=`mktemp -d ${TMPDIR:-/tmp}/buildtool.XXXXXXXXXX`
if [ -z "$TMP" ]; then
  error "ERROR: unable to create temporary working directory: aborting buildtool execution"
  exit 1
fi

# Parse arguments.
getopt -T >/dev/null 2>&1
if (( $? != 4 )); then
  echo "ERROR: GNU getopt required! Check SETUP_GETOPT and PATH" 1>&2
  exit 1
fi

TEMP=`getopt -un "$prog" --long L:,LE:,all,cmake-debug,cmake-only,cmake-profile:,cmake-trace,cmake-trace-expand,install-prefix:,build,clean,clean-logs,deleted-header:,deleted-headers:,export-compile-commands,force-top,generator:,graphviz:,gfilt::,groups:,help,info,install,labels:,log::,log-file::no-pc,no-preset-configure,package,pc:,preset-configure:,quiet,sc,short-circuit,subdir:,tee,test,test-all,test-labels:,test-groups:,release,usage,verbose -o +ACD:EG:I:RTX:bcfg:hij:lpqs:tv -- "$@"`

(( $? )) && usage 2

eval set -- "$TEMP"
while true; do
  case $1 in
    -A|--all) (( all = 1 ));;
    -C|--cmake-only) (( cmake_only = 1 ));;
    -D) cmake_defs+=("$1$2"); shift;;
    -E) require_cmake "3.5", "-E option" && \
      cmake_defs+=("-DCMAKE_EXPORT_COMPILE_COMMANDS:BOOL=ON");;
    -G) ensure_unique_gen "${@:1:2}"; shift
      generator_arg="-G$1";;
    -I|--install-prefix) install_prefix=$2;
      (( set_install_prefix = 1 )); shift;;
    --L) l_regex=$2; shift;;
    --LE) le_regex=$2; shift;;
    -R|--release) test_labels+=(RELEASE); require_tests;;
    -T|--test-all) test_labels+=(ALL); require_tests;;
    -X) argbits="$2"; shift;
      [[ "$argbits" =~ ^([cbtip]),(.*)$ ]] || \
        { error "bad argument -X$argbits"; usage 2; }
      extra_arg_type="${BASH_REMATCH[1]}"
      extra_args="${BASH_REMATCH[2]}"
      if [ -n "$extra_args" ]; then
        OIFS="${IFS}" IFS=,
        extra_opt_args=(${extra_args%%,--,*})
        extra_postargs=(${extra_args#*,--,})
        IFS="$OIFS"
        if [ "$extra_opt_args" = "--" ]; then
          eval ${extra_arg_type}_opt_args=\(\)
          eval ${extra_args_type}_postargs=\(\"\${extra_opt_args[@]:1}\"\)
        elif [ "${extra_opt_args[*]}" = "${extra_postargs[*]}" ]; then
          if [ "${extra_opt_args[@]:${#extra_opt_args[@]}-1}" = "--" ]; then
            eval ${extra_arg_type}_opt_args=\(\"\${extra_opt_args[@]:0:${#extra_opt_args[@]}-1}\"\)
          else
            eval ${extra_arg_type}_opt_args=\(\"\${extra_opt_args[@]}\"\)
          fi
          eval ${extra_arg_type}_postargs=\(\)
        else
          eval ${extra_arg_type}_opt_args=\(\"\${extra_opt_args[@]}\"\)
          eval ${extra_arg_type}_postargs=\(\"\${extra_postargs[@]}\"\)
        fi
      else
        warning "vacuous extra arguments for stage -X$extra_arg_type"
      fi;;
    -b|--build) (( do_build = 1 ));;
    --clean-logs) (( clean_logs = 1 ));;
    -c|--clean) (( clean = 1 ));;
    --cmake-debug) cmake_options+=(--debug-output);;
    --cmake-profile) cmake_options+=(--profiling-format=google-trace
        --profiling-output="$2"); shift;;
    --cmake-trace) cmake_options+=(${1/#--cmake/-});;
    --cmake-trace-expand) require_cmake 3.4 "--cmake-trace-expand option"
      cmake_options+=(${1/#--cmake/-});;
    --deleted-header|--deleted_headers) shift
      [ -n "$1" ] && add_deleted_headers "$1";;
    -f|--force-top) (( force_top = 1 ));;
    -g|--graphviz) gfile=$2; gtmpfile="$TMP/$(basename $2)"
      garg=(--graphviz "$gtmpfile"); shift;;
    --gfilt) (( gfilt = 1 )); shift
      [ -n "$1" ] && process_gfargs "$1";;
    --generator) ensure_unique_gen "${@:1:2}"; shift
      generator=${1%%:*}
      [ "$generator" != "$1" ] && secondary_generator=${1#*:}
      generator_arg="-G${secondary_generator:+$secondary_generator - }"
      case $generator in
        make) generator_arg+="Unix Makefiles";;
        ninja) generator_arg+=Ninja;;
        *) error "ERROR: unrecognized primary generator $generator"
          exit 1
      esac
      unset generator;;
    -h|--help) usage long;;
    -i|--install) (( no_build = 1 )); (( do_install = 1 ));;
    --info) (( want_info = 1 ));;
    -j) plevel="$2"; shift;;
    -l) log="$log_default"; (( log_is_default = 1 ));;
    --log|--log-file) shift
      [ -d "$1" ] && log="$1/$log_default" || \
        log="${1:-${log:-$log_default}}"
      [ "$1" = "${log%/*}" ] && (( log_is_default = 1 )) || unset log_is_default;;
    --no-pc|--no-preset-configure) preset_configure=""; shift;;
    -p|--package) (( no_build = 1 )); (( do_package = 1 ));;
    --pc|--preset-configure) require_cmake 3.20; preset_configure="$2"; shift;;
    -q|--quiet) (( quiet = 1 ));;
    -s|--subdir) subdir="$2"; shift;;
    --short-circuit|--sc) (( short_circuit = 1 ));;
    -t|--test) require_tests;;
    --tee) log="${log:-$log_default}"; (( tee = 1 ));;
    --test-labels|--labels|--test-groups|--groups)
      tmp_arg="$2"
      OIFS="$IFS"; IFS=","; test_labels+=($tmp_arg); IFS="$OIFS"
      shift;;
    --usage) usage;;
    -v|--verbose) (( _cet_do_verbose = 1 ));;
    --) shift; break;;
    *) echo "Bad argument $1" 1>&2; usage 2
  esac
  shift
done

##################
# Basic safety checks.
cetpkg_build="$(real_dir "$CETPKG_BUILD")"
cetpkg_source="$(real_dir "$CETPKG_SOURCE")"

if [ -z "$CETPKG_BUILD" ]; then
  fatal_error "expected CETPKG_BUILD and friends to be set: source setup_for_development?"
elif [ ! -d "$CETPKG_BUILD" ] || [ ! -w "$CETPKG_BUILD" ]; then
  fatal_error "CETPKG_BUILD \"$CETPKG_BUILD\" does not exist,
             is not a directory or is not writable"
elif [ "$cetpkg_build" = "$cetpkg_source" ]; then
  fatal_error "CETPKG_BUILD ($CETPKG_BUILD) is identical to CETPKG_SOURCE"
elif [[ "$cetpkg_build" == "$cetpkg_source"/* ]]; then
  fatal_error "CETPKG_BUILD ($CETPKG_BUILD) is a subdir of
             CETPKG_SOURCE ($CETPKG_SOURCE)"
elif [[ "$cetpkg_source" == "$cetpkg_build"/* ]]; then
  fatal_error "CETPKG_SOURCE ($CETPKG_SOURCE) is a subdir of
             CETPKG_BUILD ($CETPKG_BUILD)"
elif [ -f "$CETPKG_BUILD/CMakeLists.txt" ]; then
  fatal_error "CETPKG_BUILD ($CETPKG_BUILD) has a CMakeLists.txt file:
             also a source area?"
elif ! [ -r "${CETPKG_SOURCE}/CMakeLists.txt" ]; then
  fatal_error "CMakeLists.txt nonexistent or not readable in CETPKG_SOURCE
             (${CETPKG_SOURCE})"
elif ! grep -qEie '^[[:space:]]*project[[:space:]]*\(' "${CETPKG_SOURCE}/CMakeLists.txt" 2>/dev/null; then
  fatal_error "no project() call in top level CMakeLists.txt
             (${CETPKG_SOURCE}/CMakeLists.txt)"
elif [ "$cetpkg_build" = "/" ]; then
  fatal_error "CETPKG_BUILD == /"
elif [[ "$CETPKG_BUILD" != /* ]]; then
  fatal_error "CETPKG_BUILD appears to be relative"
elif [ "$cetpkg_build" = "$(real_dir "$HOME")" ] || \
  [ "$cetpkg_build" = "$(real_dir ~)" ]; then
  fatal_error "CETPKG_BUILD has been set to your home directory"
fi
##################

[ -r "$CETPKG_BUILD/cetpkg_info.sh" ] || \
  fatal_error "unable to read $CETPKG_BUILD/cetpkg_info.sh - source setup_for_development?"

source "$CETPKG_BUILD/cetpkg_info.sh" || \
  fatal_error "error sourcing $CETPKG_BUILD/cetpkg_info.sh"

# Command to use to get NFS-safe filesystem locks.
lock_cmd=("$libexec/cet_lock"
          -d "${CETPKG_BUILD}/.locks"
          -l "$prog"
          -r "$CETPKG_NAME-$CETPKG_VERSION"
          -s 5
          -t 30
)

(( _cet_redirected )) && lock_cmd+=(-R)
(( _cet_verbose )) && lock_cmd+=(-v)

if (( log_is_default )); then
  # Update the default log file name with what we know.
  log="$( cd "$(dirname "${log}")" && pwd)"
  log_bits=("${log:+$log/}build_$CETPKG_NAME"
    $CETPKG_VERSION
    ${CETPKG_QUALSPEC//:/_}
    ${log_default#build_}
  )
  OIFS="$IFS"; IFS="_"; log="${log_bits[*]}"; IFS="$OIFS"
fi

##################
# Argument consistency checks.
(( force_top )) && [ -n "$subdir" ] && \
  fatal_error "specifying --force-top and --subdir together is not meaningful"

(( ${#test_labels[@]} )) && \
  { [ -n "$l_regex" ] || [ -n "$le_regex" ]; } && \
  fatal_error "--LE and --L are mutually-exclusive with -T, -R, and --test-labels and synonyms"
##################

##################
# Subdirectory arithmetic.
user_cwd="$(real_dir .)/"
user_subdir="${user_cwd#$cetpkg_build/}"
if [ -n "$subdir" ]; then
  real_subdir="$(cd "$CETPKG_BUILD"; real_dir "$subdir")/"
  real_subdir="${real_subdir#$cetpkg_build/}"
  if [ "${real_subdir:0:1}" == "/" ]; then
    fatal_error "specified subdir \"$subdir\" is not a subdirectory of $CETPKG_BUILD"
  else
    subdir="${real_subdir}"
  fi
fi
calculate_ops_dir
##################

##################
# Parallelism
[ -n "$plevel" ] || plevel=$CETPKG_J
if [ -n "$plevel" ]; then
  export CMAKE_BUILD_PARALLEL_LEVEL=$plevel
  export CTEST_PARALLEL_LEVEL=$plevel
fi
##################

##################
# Bootstrapping
cmake_bootstrap_defs=()
[ -n "$CETMODULES_DIR" ] && \
  ! [ "${CETPKG_SOURCE}" = "${MRB_SOURCE}" ] && \
  cmake_bootstrap_defs+=("-DCMAKE_PROJECT_INCLUDE_BEFORE=${CETMODULES_DIR}/Modules/BootstrapCetmodules.cmake")
##################

# If desired, print current build information and quit.
(( want_info )) && basic_info && exit || true

# Make sure output will appear as we'd like.
if (( tee )) && (( quiet )); then
  # You asked for stuff to the screen -- that's what you'll get.
  warning "--tee option overrides --quiet"
  unset quiet
fi

# If you're logging to file (but not using tee) we don't want quiet.
(( log_no_tee )) && unset quiet

# Did we specify all?
if (( all )); then
  (( do_build )) || (( do_build = 2 ))
  (( do_test )) || (( do_test = 2 ))
  (( do_install = 1 ))
  (( do_package = 1 ))
else
  # In general, build unless we've been asked not to where that is
  # compatible with our other options.
  (( do_build )) || (( no_build )) || (( do_build = 2 ))
fi

# Possibly clean up.
if (( clean )); then
  [ -z "$user_subdir" ] || [ "$user_cwd" = "$user_subdir" ] || \
    fatal_error "clean operation would remove the current directory: $user_cwd"
  (( $(ls -1 "$CETPKG_BUILD" | wc -l) )) && \
    ! [ -f "$CETPKG_BUILD/cetpkg_info.sh" ] && \
    fatal_error "refusing to clean suspect non-empty build directory
              \$CETPKG_BUILD (\"$CETPKG_BUILD\")
              Double-check and re-source setup_for_development"
  trap "f=$?; printf -- \"\nAborted\n\" 1>&2; cleanup; exit $f" 2
  printf -- "$(quiet= info "about to clean \"$CETPKG_BUILD\": ctrl-C to abort within 5 seconds ")"
  for i in 1 2 3 4 5; do printf -- "."; sleep 1; done
  printf -- "\n";
  pushd /tmp >/dev/null
  info "cleaning \"$CETPKG_BUILD\""
  setup_files_backup="$TMP/setup_files-backup.tar"
  ( cd "$CETPKG_BUILD" && \
    tar -f "$setup_files_backup" -c */table_* || \
    rm -f "$setup_files_backup" ) > /dev/null 2>&1
  if ! { find "$CETPKG_BUILD" -mindepth 1 -maxdepth 1 \
              \( -type d -name "$CET_SUBDIR" \) -o \
              \( \( -type d -o -name 'build.ninja' -o -name '.ninja_deps' -o \
              -name '*.cmake' -o -name '*.cmake.in' -o -name 'DartConfiguration.tcl' -o \
              -name 'CMakeCache.txt' -o -name 'install_manifest.txt' -o \
              -name 'Makefile' \) -print0 \)
         find "$CETPKG_BUILD/$CET_SUBDIR" -mindepth 1 -maxdepth 1 \
              \( -name 'CPAN' -o -name 'cpan_build' \) -o -print0
       } 2>/dev/null | xargs -0 rm -rf; then
    fatal_error "unable to clean directory \"$CETPKG_BUILD\""
  fi
  if [ -r "$setup_files_backup" ]; then
    tar -C "$CETPKG_BUILD" -f "$setup_files_backup" -x >/dev/null 2>&1 || \
      { unset TMP
      fatal_error "unable to restore setup files from $setup_files_backup after clean"
    }
  fi
  popd >/dev/null || cd "$CETPKG_BUILD" # 2>&1
  trap 2
  (( short_circuit )) && ! (( clean_logs )) && exit || true
else # Check consistency.
  # product_deps is read and acted upon during source of
  # setup_for_development. If it's changed since then, we have a
  # problem.
  [ "$CETPKG_SOURCE/ups/product_deps" -nt \
    "$CETPKG_BUILD/cetpkg_info.sh" ] && \
    fatal_error "product_deps has changed since the last time setup_for_development
             was sourced: re-source before building"
  check_build_type="$(cmake_var CMAKE_BUILD_TYPE)"
  (( $? == 0 )) && \
    [ "$check_build_type" != "$CETPKG_CMAKE_BUILD_TYPE" ] && \
    fatal_error "build type has changed from \"$check_build_type\" to \"$CETPKG_CMAKE_BUILD_TYPE:\" need clean build"
  CETPKG_CMAKE_PROJECT_NAME=$(cmake_var "UPS_${CETPKG_NAME}_CMAKE_PROJECT_NAME")
  if (( $? == 0 )); then
    check_fq_dir="$(cmake_var ${CETPKG_CMAKE_PROJECT_NAME}_EXEC_PREFIX)"
    (( $? == 0 )) && \
      [ "$check_fq_dir" != "$CETPKG_FQ_DIR" ] && \
      fatal_error "FQ_DIR has changed from $check_fq_dir to $CETPKG_FQ_DIR: need clean build"
    check_qual="$(cmake_var ${CETPKG_CMAKE_PROJECT_NAME}_UPS_QUALIFIER_STRING)"
    (( $? == 0 )) && \
      [ "$check_qual" != "$CETPKG_QUALSPEC" ] && \
      fatal_error "qualifier has changed from \"$check_qual\" to \"$CETPKG_QUALSPEC\": need clean build"
  fi
fi

if (( clean_logs )); then
  info "removing .log files from \"$CETPKG_BUILD\""
  rm -f "$CETPKG_BUILD"/*.log "$CETPKG_BUILD/.ninja_log"
  (( short_circuit )) && exit || true
fi

# Set install prefix from wherever we can get it.
(( set_install_prefix )) || \
  install_prefix="${install_prefix:-${CETPKG_INSTALL:-$(cmake_var CMAKE_INSTALL_PREFIX)}}"

if (( do_install )); then
  if [ -z "$install_prefix" ]; then
    warning "unspecified or null install prefix defaulted to /dev/null"
    install_prefix=/dev/null
  elif ! { [ -d "$install_prefix" ] || \
    mkdir "$install_prefix"; } && [ -w "$install_prefix" ]; then
    fatal_error "install prefix \"$install_prefix\" does not exist as a directory,
             cannot be made in an existing parent directory, or is not writable"
  else
    install_prefix="$(real_dir "$install_prefix")"
  fi
fi

info "install prefix = $install_prefix"

# Suppress messages if desired.
(( quiet )) && exec >/dev/null

if [[ "$generator_arg" == *Ninja* ]]; then
  type -t ninja 2>&1 >/dev/null || \
    fatal_error "Ninja generator is specified via $generator_arg, but ninja application is not available"
  (( using_ninja = 1 ))
fi

[[ -n "$*" ]] && report "Additional arguments for cmake --build (build, install, package): $*"

# If we're tee-ing.
if (( tee )); then
  do_work "$@" 2>&1 | tee "$log"
else
  do_work "$@"
fi

# Done.
